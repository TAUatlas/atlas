#include "config.h"

#include <xdc/runtime/System.h>

#include <ti/devices/cc13x0/driverlib/rf_mailbox.h>
#include <ti/devices/cc13x0/driverlib/rf_common_cmd.h>
#include <ti/devices/cc13x0/driverlib/rf_prop_cmd.h>
#include <ti/drivers/rf/RF.h>
#ifdef CC1310
//#include <rf_patches/rf_patch_cpe_genfsk.h>
//#include <rf_patches/rf_patch_rfe_genfsk.h>
//#include <rf_patches/rf_patch_cpe_lrm.h>
//#include <rf_patches/apply_lrm_mce_patch.h>
// got the file below from SVS on E2E
#include "apply_lrm_mce_patch.h"
#include "rf_patch_cpe_genfsk.h"
#include "rf_patch_rfe_genfsk.h"
#include "rf_patch_cpe_lrm.h"
#endif

#ifdef CC2650
#include "apply_patch.h"
#include "apply_genfsk_rfe_patch.h"
#include "apply_genfsk_mce_patch.h"
#endif

#include "radio_setup.h"

/*********************************************************************************/

/*********************************************************************************/
/* A COLLECTION OF SYNC WORDS                                                    */
/*********************************************************************************/

#define SYNCWORD16_SILABS 0x2DD4
#define SYNCWORD32_SILABS 0x5A0FBE66
#define SYNCWORD16_TI_WOR 0xD391


//*********************************************************************************
// These settings have been generated for use with TI-RTOS and cc13xxware
//
// Generated by SmartRF Studio version 2.4.0
// Tested for TI-RTOS version tirtos_simplelink_2_20_xx
// Device: CC13xx Rev. 2.1
//
//*********************************************************************************


//*********************************************************************************
// Parameter summary
// Address: aa-bb
// Frequency: 868.00000 MHz
// Data Format: Serial mode disable
// Deviation: 25.000 kHz
// Packet Length Config: Variable
// Max Packet Length: 125
// Packet Length: 30
// RX Filter BW: 98 kHz
// Symbol Rate: 50.00000 kBaud
// Sync Word Length: 32 Bits
// TX Power: 14 dBm (requires define CCFG_FORCE_VDDR_HH = 1 in ccfg.c, see CC13xx/CC26xx Technical Reference Manual)
// Whitening: No whitening

void radioSetup_init() {
	// we copy from the template structures to the others, so we can modify them later
	int i;
	for (i=1; i<MAX_RADIO_SETUPS; i++) {
		radio_mode              [i] = radio_mode              [0];
		radio_cmd_prop_div_setup[i] = radio_cmd_prop_div_setup[0];
		radio_cmd_prop_tx       [i] = radio_cmd_prop_tx       [0];
		radio_cmd_prop_tx_adv   [i] = radio_cmd_prop_tx_adv   [0];
		radio_cmd_prop_rx       [i] = radio_cmd_prop_rx       [0];
		radio_cmd_fs            [i] = radio_cmd_fs            [0];
	}
}

//#define DEVIATION_STEP_SIZE  250

// documentation for the divider: Supported values: 2 (CC1350 only), 5, 6, 10, 12, 15, and 30

static uint16_t bands_los[][2] = {
		{ 150, 30 }, // sivan experimental
		{ 315, 14 }, // not sure where the 14 is from, maybe 12 or 15 is better
		{ 433, 10 },
		{ 868,  5 },
		{ 915,  5 },
		{ 1280,  3 }, // best value is probably between 3 and 4; may not work
		{   0,  0 }
};

void radioSetup_frequency(uint32_t index, uint32_t f) {
	radio_cmd_fs[index].frequency = f / 1000000;
	radio_cmd_fs[index].fractFreq = (uint16_t) (((double) (f - 1000000*(radio_cmd_fs[index].frequency)) / 1e6) * 65535);

	System_printf("f=%d full %d frac ==> %.6f\n",
			radio_cmd_fs[index].frequency,radio_cmd_fs[index].fractFreq,
			(double)(radio_cmd_fs[index].frequency)+(double)(radio_cmd_fs[index].fractFreq)/65535.0);

	if (f < 1000000000) {
		int32_t mindiff  = -1;
		int     minindex = 0;
		int i;
		for (i=0; bands_los[i][0]; i++) {
			int32_t diff = f - bands_los[i][0]*1000000;
			if (diff < 0) diff = -diff;
			if (mindiff == -1 || diff < mindiff) {
				mindiff  = diff;
				minindex = i;
			}
		}
		System_printf("sub-1GHz f=%d band %d div %d\n",f,bands_los[minindex][0],bands_los[minindex][1]);
		radio_cmd_prop_div_setup[index].centerFreq = bands_los[minindex][0];
		radio_cmd_prop_div_setup[index].loDivider  = bands_los[minindex][1];
	}
}

static uint16_t cc1310_rxbw[][2] = {
		{ 4240, 52 },
		{ 3470, 51 },
		{ 2800, 50 },
		{ 2120, 49 },
		{ 1740, 48 },
		{ 1410, 47 },
		{ 1060, 46 },
		{  870, 45 },
		{  700, 44 },
		{  530, 43 },
		{  430, 42 },
		{  350, 41 },
		{  260, 40 },
		{  220, 39 },
		{  180, 38 },
		{  130, 37 },
		{  110, 36 },
		{   88, 35 },
		{   66, 34 },
		{   55, 33 },
		{   45, 32 },
		{    0, 32 }
};

void radioSetup_modulation(uint32_t index, uint8_t modulation_type,
                              		uint32_t symbolrate,
		                              uint32_t deviation,
																	uint32_t rxbw) {

	radio_cmd_prop_div_setup[index].modulation.modType   = modulation_type;
	radio_cmd_prop_div_setup[index].modulation.deviation = deviation / DEVIATION_STEP_SIZE;

	System_printf("deviation %d = %d * 250 mod %d\n",deviation,radio_cmd_prop_div_setup[index].modulation.deviation,modulation_type);

	uint8_t  p;
	uint32_t r;

	p = 15;
	if (symbolrate >  50000) p = 6;
	if (symbolrate > 500000) p = 5;

	//for (p=15; p>=4; p--) {
	{
		r = (uint32_t) (((double) symbolrate * 1048576 * p) / 24e6);
		System_printf("symbolrate %d p=%d r=%d ==> %f\n",symbolrate,r,p, (24e6*r) / (1048576 * p));
		if (r < 2097152) {
			radio_cmd_prop_div_setup[index].symbolRate.preScale = p;
			radio_cmd_prop_div_setup[index].symbolRate.rateWord = r;
			//break;
		}
	}

	int i;
	for (i=0; rxbw <= 1000*cc1310_rxbw[i+1][0]; i++);
	System_printf("rxbw %d >= %d (%d)\n", rxbw, cc1310_rxbw[i][0], cc1310_rxbw[i][1]);
	radio_cmd_prop_div_setup[index].rxBw = cc1310_rxbw[i][1];

	if (symbolrate > 50000) radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 8;
	else                    radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 5;
}

// smartrf also shows -10dBm --> 0x08c0
static const int8_t power_setting_start = 0;
static const uint16_t power_setting[] = {
	0x0041, // 0dBm
	0x10c3,
	0x1042,
	0x14c4, // 0dBm
	0x18c5,
	0x18c6, // 5
	0x1cc7,
	0x20c9,
	0x24cb,
	0x2ccd, // 9
	0x38d3, // 10dBm
	0x50da, // 11
	0xb818, // 12
	0xa63f, // 12.5dBm
	0xa73f // 14dBm (if VDDR boost)
};

void radioSetup_txPower(uint32_t index, int8_t dbm) {
	System_printf("power setting 0x%04x\n",power_setting[ dbm - power_setting_start ]);
	radio_cmd_prop_div_setup[index].txPower = power_setting[ dbm - power_setting_start ];
}


RF_Mode radio_mode[MAX_RADIO_SETUPS] = {
{
#ifdef CC1310
  .rfMode = RF_MODE_PROPRIETARY_SUB_1,
	.cpePatchFxn = &rf_patch_cpe_genfsk,
	.mcePatchFxn = 0,
	.rfePatchFxn = &rf_patch_rfe_genfsk,
#endif
#ifdef CC2650
	.rfMode = RF_MODE_PROPRIETARY,	// 0x3
	.cpePatchFxn = &applyPatch,
	.mcePatchFxn = &enterGenfskMcePatch,
	.rfePatchFxn = &enterGenfskRfePatch,
#endif
}};

// Enhanced GFSK shape (reduced ISI) for 25 kHz deviation
uint32_t gfsk25kHzShape[] = {0x00000000, 0x00000000, 0x07040201, 0x281D140C, 0x4E473E33, 0x5A595754};

// Enhanced GFSK shape (reduced ISI) for 37.5 kHz deviation
uint32_t gfsk37_5kHzShape[] = {0x00000000, 0x01000000, 0x0B060301, 0x3B2B1D12, 0x74695B4B, 0x8483807B};

// Enhanced GFSK shape (reduced ISI) for 50 kHz deviation
uint32_t gfsk50kHzShape[] = {0x00000000, 0x01000000, 0x0E080402, 0x4E392718, 0x9A8C7A64, 0xB0AFABA4};

uint32_t cc2650_50kbps_pOverrides[] = {
		0x00001107, // Run patched MCE and RFE code from RAM
		0x00354038, // Synth: Set RTRIM (POTAILRESTRIM) to 5
		0x4001402D, // Synth: Correct CKVD latency setting (address)
		0x00608402, // Synth: Correct CKVD latency setting (value)
		0x4001405D, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (address)
		0x1801F800, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (value)
		0x000584A3, // Synth: Set FREF = 4.8 MHz (24 MHz / 5)
		0xC0040031, // Provide custom shape
		(uint32_t) gfsk50kHzShape, // Pointer to shape
		0xFFFFFFFF, // End of override list
};

/* Use for 250kbps */
uint32_t cc2650_250kbps_pOverrides[] = {
		0x00001107, // Run patched MCE and RFE code from RAM
		0x00354038, // Synth: Set RTRIM (POTAILRESTRIM) to 5
		0x4001402D, // Synth: Correct CKVD latency setting (address)
		0x00608402, // Synth: Correct CKVD latency setting (value)
		0x4001405D, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (address)
		0x1801F800, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (value)
		0x000584A3, // Synth: Set FREF = 4.8 MHz (24 MHz / 5)
//		0xC0040031, // Provide custom shape
//		(uint32_t) gfsk50kHzShape, // Pointer to shape
		0xFFFFFFFF, // End of override list
};


// Overrides for CMD_PROP_RADIO_DIV_SETUP
static uint32_t gfskOverrides[] = {
    // override_use_patch_prop_genfsk.xml
    // PHY: Use MCE ROM bank 4, RFE RAM patch
    MCE_RFE_OVERRIDE(0,4,0,1,0,0),
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout
    (uint32_t)0x04B00243,
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_agc_reflevel_0x1a.xml
    // Tx: Enable PA ramping (0x41). Rx: Set AGC reference level to 0x1A.
    HW_REG_OVERRIDE(0x6088,0x411A),
    // Tx: Configure PA ramping setting
    HW_REG_OVERRIDE(0x608C,0x8213),
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_frontend_xd.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB
    (uint32_t)0x00FB88A3,
    (uint32_t)0xFFFFFFFF,
};

static uint32_t lrmOverrides[] =
{
    // override_use_prop_lrm_rom.xml
    // PHY: Use MCE ROM bank 3, RFE ROM bank 4
    MCE_RFE_OVERRIDE(0,3,0,0,4,0),
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout
    (uint32_t)0x04B00243,
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_agc_reflevel_0x1a.xml
    // Rx: Set AGC reference level to 0x1A
    HW_REG_OVERRIDE(0x6088,0x001A),
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_phy_lrm_rom_dsss8.xml
    // PHY: Configure DSSS=8
    HW_REG_OVERRIDE(0x505C,0x073C),
    // override_frontend_xd.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB
    (uint32_t)0x00FB88A3,
    // TX power override
    // Tx: Set PA trim to max (in ADI0, set PACTL0=0xF8)
    ADI_REG_OVERRIDE(0,12,0xF8),
    (uint32_t)0xFFFFFFFF,
};

// Overrides for CMD_PROP_RADIO_DIV_SETUP
uint32_t fastlrmOverrides[] =
{
    MCE_RFE_OVERRIDE(1, 0, 0, 0, 4, 0), // MCE run from RAM, No RFE patch (PA ramping)
    HW32_ARRAY_OVERRIDE(0x6088,1),
    (uint32_t)0x0000001A,
    HW32_ARRAY_OVERRIDE(0x4038,1),
    (uint32_t)0x0000003A,
    HW_REG_OVERRIDE(0x4020,0x7F00),
    HW_REG_OVERRIDE(0x4064,0x0040),
    (uint32_t)0x684A3,   // Synth: Set FREF = 4 MHz (24 MHz / 6)
    (uint32_t)0xC0040141,
    (uint32_t)0x0533B107,
    (uint32_t)0x0A480583,
    (uint32_t)0x7AB80603,
    (uint32_t)0x02010403,
    (uint32_t)0x00108463,
    (uint32_t)0x04B00243,
    ADI_REG_OVERRIDE(1,4,0x9F),
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    HW_REG_OVERRIDE(0x6084,0x35F1),
    (uint32_t)0x00038883,
    (uint32_t)0x00FB88A3,
    HW_REG_OVERRIDE(0x6088,0x1F0E), // AGC reference level
    // TX power override
    ADI_REG_OVERRIDE(0,12,0xF9),
    // Overrides for LRM
    HW_REG_OVERRIDE(0x52AC,0x0F33), //DSSS = 8, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0B03), //DSSS = 4, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0900), //DSSS = 2, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0800), //DSSS = 1, K=4
    HW_REG_OVERRIDE(0x5108,0x0048), //Correlator Threshold for Sync
    (uint32_t)0xFFFFFFFF,
};


void radioSetup_packetFormat(uint32_t index, int8_t packetFormat) {
	switch (packetFormat) {
	case DATA_ENCODING_CC1310_FASTLRM:
		System_printf("enc fastlrm\n");
		radio_cmd_prop_div_setup[index].formatConf.fecMode = 0; // weird, but this is the setup from SVS
		radio_cmd_prop_div_setup[index].pRegOverride = fastlrmOverrides;

		radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
		radio_mode[index].mcePatchFxn = &enterLrmMcePatch;
		radio_mode[index].rfePatchFxn = 0;
		break;
	case DATA_ENCODING_CC1310_LRM:
		System_printf("enc lrm\n");
		radio_cmd_prop_div_setup[index].formatConf.fecMode = 8;
		radio_cmd_prop_div_setup[index].pRegOverride = lrmOverrides;

		radio_mode[index].cpePatchFxn = &rf_patch_cpe_lrm;
		radio_mode[index].mcePatchFxn = 0;
		radio_mode[index].rfePatchFxn = 0;
		break;
	case DATA_ENCODING_PLAIN:
	default:
		System_printf("enc plain\n");
		radio_cmd_prop_div_setup[index].formatConf.fecMode = 0;
		radio_cmd_prop_div_setup[index].pRegOverride = gfskOverrides;

		radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
		radio_mode[index].mcePatchFxn = 0;
		radio_mode[index].rfePatchFxn = &rf_patch_rfe_genfsk;
		break;
	}
}

rfc_CMD_PROP_RADIO_DIV_SETUP_t radio_cmd_prop_div_setup[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_PROP_RADIO_DIV_SETUP,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = TRIG_NOW, //0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

		.modulation.modType = 0x1,
    .modulation.deviation = 0x64,
    .symbolRate.preScale = 0xF,
    .symbolRate.rateWord = 0x8000,
    .rxBw = 0x24,
    .preamConf.nPreamBytes = 5, //0x4,
    .preamConf.preamMode = 0x0,
    .formatConf.nSwBits = 32, //0x20,
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x1,
    .formatConf.fecMode = 0x0,
    .formatConf.whitenMode = 0x0,
    .config.frontEndMode = 0x0,
    .config.biasMode = 0x1,
    .config.analogCfgMode = 0x0,
    .config.bNoFsPowerUp = 0x0,
    .txPower = 0x38D3,
    .pRegOverride = lrmOverrides,
    .centerFreq = 0x0364,
    .intFreq = 0x8000,
    .loDivider = 0x05,}};

// CMD_FS
rfc_CMD_FS_t radio_cmd_fs[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_FS, // 0x0803,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = TRIG_NOW, // 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .frequency = 0x0364,
    .fractFreq = 0x0000,
    .synthConf.bTxMode = 0x0,
    .synthConf.refFreq = 0x0,
    .__dummy0 = 0x00,
    .__dummy1 = 0x00,
    .__dummy2 = 0x00,
    .__dummy3 = 0x0000,
}};

// CMD_PROP_TX
rfc_CMD_PROP_TX_t radio_cmd_prop_tx[MAX_RADIO_SETUPS] = {
  {
    .commandNo = CMD_PROP_TX, // 0x3801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktLen = 0x1E, // SET APPLICATION PAYLOAD LENGTH
    .syncWord = 0x930B51DE,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
  }
};

// CMD_PROP_RX
rfc_CMD_PROP_RX_t radio_cmd_prop_rx[MAX_RADIO_SETUPS] = {
{
      .commandNo = CMD_PROP_RX, // 0x3802,
	  	.status = 0x0000,
		  .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
	  	.startTime = 0x00000000,
  		.startTrigger.triggerType = 0x0,
	    .startTrigger.bEnaCmd = 0x0,
	    .startTrigger.triggerNo = 0x0,
	    .startTrigger.pastTrig = 0x0,
	    .condition.rule = 0x1,
	    .condition.nSkip = 0x0,

			.pktConf.bFsOff = 0x0,
	    .pktConf.bRepeatOk = 0x1,
	    .pktConf.bRepeatNok = 0x1,
	    .pktConf.bUseCrc = 0x1,
	    .pktConf.bVarLen = 0x1,
	    .pktConf.bChkAddress = 0x0,
	    .pktConf.endType = 0x0,
	    .pktConf.filterOp = 0x0,
	    .rxConf.bAutoFlushIgnored = 0x0,
	    .rxConf.bAutoFlushCrcErr = 0x0,
	    .rxConf.bIncludeHdr = 0x1,
	    .rxConf.bIncludeCrc = 0x0,
	    .rxConf.bAppendRssi = 0x1,
	    .rxConf.bAppendTimestamp = 0x1,
	    .rxConf.bAppendStatus = 0x1,
	    .syncWord = 0x930B51DE,
	    .maxPktLen = 0x80, // MAKE SURE DATA ENTRY IS LARGE ENOUGH
	    .address0 = 0xAA,
	    .address1 = 0xBB,
	    .endTrigger.triggerType = TRIG_NEVER, // 0x1,
	    .endTrigger.bEnaCmd = 0x0,
	    .endTrigger.triggerNo = 0x0,
	    .endTrigger.pastTrig = 0x0,
	    .endTime = 0x00000000,
	    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
	    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
}};

// CMD_PROP_RX_ADV
rfc_CMD_PROP_RX_ADV_t RF_cmdPropRxAdv =
{
    .commandNo = 0x3804,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

		.pktConf.bFsOff = 0x0,
    .pktConf.bRepeatOk = 0x0,
    .pktConf.bRepeatNok = 0x0,
    .pktConf.bUseCrc = 0x0,
    .pktConf.bCrcIncSw = 0x0,
    .pktConf.bCrcIncHdr = 0x0,
    .pktConf.endType = 0x0,
    .pktConf.filterOp = 0x0,
    .rxConf.bAutoFlushIgnored = 0x0,
    .rxConf.bAutoFlushCrcErr = 0x0,
    .rxConf.bIncludeHdr = 0x0,
    .rxConf.bIncludeCrc = 0x0,
    .rxConf.bAppendRssi = 0x0,
    .rxConf.bAppendTimestamp = 0x0,
    .rxConf.bAppendStatus = 0x0,
    .syncWord0 = 0x00000000,
    .syncWord1 = 0x00000000,
    .maxPktLen = 0x0000,
    .hdrConf.numHdrBits = 0x0,
    .hdrConf.lenPos = 0x0,
    .hdrConf.numLenBits = 0x0,
    .addrConf.addrType = 0x0,
    .addrConf.addrSize = 0x0,
    .addrConf.addrPos = 0x0,
    .addrConf.numAddr = 0x0,
    .lenOffset = 0x00,
    .endTrigger.triggerType = 0x0,
    .endTrigger.bEnaCmd = 0x0,
    .endTrigger.triggerNo = 0x0,
    .endTrigger.pastTrig = 0x0,
    .endTime = 0x00000000,
    .pAddr = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

rfc_CMD_PROP_TX_ADV_t radio_cmd_prop_tx_adv[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_PROP_TX_ADV,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc    = 1,
    .pktConf.bCrcIncSw  = 0,
    .pktConf.bCrcIncHdr = 1, // 1 here is the equivalent of CMD_PROP_TX
    .numHdrBits         = 8, // 8 here is the equivalent of CMD_PROP_TX
    .pktLen             = 0x0000,
    .startConf.bExtTxTrig   = 0,
    .startConf.inputMode    = 0,
    .startConf.source       = 0,
    .preTrigger.triggerType = TRIG_NOW,
    .preTrigger.bEnaCmd     = 0,
    .preTrigger.triggerNo   = 0,
    .preTrigger.pastTrig    = 1,
    .preTime                = 0,
    .syncWord = 0x930B51DE,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
}
};

/*******************************************************************************/
/* values received from TI empolyee SVD on E2E                                 */
/*******************************************************************************/

// TI-RTOS RF Mode Object
RF_Mode radio_mode_fastlrm =
{
    .rfMode = RF_MODE_PROPRIETARY_SUB_1, //RF_MODE_PROPRIETARY,
    .cpePatchFxn = &rf_patch_cpe_genfsk,
    .mcePatchFxn = &enterLrmMcePatch,
    .rfePatchFxn = 0,
};


// CMD_PROP_RADIO_DIV_SETUP
rfc_CMD_PROP_RADIO_DIV_SETUP_t radio_cmd_prop_div_setup_fastlrm =
{
    .commandNo = 0x3807,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .modulation.modType = 0x0,          //Changed for LRM mode
    .modulation.deviation = 0x2BC,      //175KHz deviation (250*100)
    .symbolRate.preScale = 0xf,         //Prescalar value of 15
    .symbolRate.rateWord = 0x50000,     //500kbps with prescalar of 15.
    .rxBw = 0x2F,                       //1410KHz bandwidth
    .preamConf.nPreamBytes = 0x4,
    .preamConf.preamMode = 0x0,
    .formatConf.nSwBits = 0x20,         //32 bit Sync word
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x0,        //LSB transmitted first for LRM mode
    .formatConf.fecMode = 0x0,          //Uncoded
    .formatConf.whitenMode = 0x0,
    .config.frontEndMode = 0x0,         //Differential
    .config.biasMode = 0x1,             //External Bias
    .config.bNoFsPowerUp = 0x0,
    .txPower = 0xa73f,
    .pRegOverride = fastlrmOverrides,
    .centerFreq = 0x0393,
    .intFreq = 0x8000,                  //TX IF default, 1MHz IF for RX
    .loDivider = 0x05,
};

// CMD_FS
rfc_CMD_FS_t radio_cmd_fs_fastlrm =
{
    .commandNo = 0x0803,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .frequency = 0x0393,                //915MHz frequency
    .fractFreq = 0x0000,
    .synthConf.bTxMode = 0x0,
    .synthConf.refFreq = 0x0,
    .__dummy0 = 0x00,
    .__dummy1 = 0x00,
    .__dummy2 = 0x00,
    .__dummy3 = 0x0000,
};

// CMD_PROP_TX
rfc_CMD_PROP_TX_t radio_cmd_prop_tx_fastlrm =
{
    .commandNo = 0x3801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktLen = 0x1e, // SET APPLICATION PAYLOAD LENGTH
    .syncWord = 0x333C3C33,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

// CMD_PROP_RX
rfc_CMD_PROP_RX_t radio_cmd_prop_rx_fastlrm =
{
    .commandNo = 0x3802,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bRepeatOk = 0x0,
    .pktConf.bRepeatNok = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktConf.bChkAddress = 0x0,
    .pktConf.endType = 0x0,
    .pktConf.filterOp = 0x0,
    .rxConf.bAutoFlushIgnored = 0x1,
    .rxConf.bAutoFlushCrcErr = 0x1,
    .rxConf.bIncludeHdr = 0x1,
    .rxConf.bIncludeCrc = 0x0,
    .rxConf.bAppendRssi = 0x1,
    .rxConf.bAppendTimestamp = 0x1,
    .rxConf.bAppendStatus = 0x1,
		.syncWord = 0x333C3C33,
    .maxPktLen = 100, // MAKE SURE DATA ENTRY IS LARGE ENOUGH
    .address0 = 0xaa,
    .address1 = 0xbb,
    .endTrigger.triggerType = 0x1,
    .endTrigger.bEnaCmd = 0x0,
    .endTrigger.triggerNo = 0x0,
    .endTrigger.pastTrig = 0x0,
    .endTime = 0x00000000,
    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

rfc_CMD_PROP_TX_ADV_t radio_cmd_prop_tx_adv_fastlrm =
{
    .commandNo = CMD_PROP_TX_ADV,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

		.pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc    = 1,
    .pktConf.bCrcIncSw  = 0,
    .pktConf.bCrcIncHdr = 1, // 1 here is the equivalent of CMD_PROP_TX
    .numHdrBits         = 8, // 8 here is the equivalent of CMD_PROP_TX
    .pktLen             = 0x0000,

		.startConf.bExtTxTrig   = 0,
    .startConf.inputMode    = 0,
    .startConf.source       = 0,
    .preTrigger.triggerType = TRIG_NOW,
    .preTrigger.bEnaCmd     = 0,
    .preTrigger.triggerNo   = 0,
    .preTrigger.pastTrig    = 1,
    .preTime                = 0,

		//.syncWord = 0x930B51DE,
    .syncWord = 0x333C3C33,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

void radioSetup_setFastLRM(uint32_t i) {
	radio_mode              [i] = radio_mode_fastlrm              ;
	radio_cmd_prop_div_setup[i] = radio_cmd_prop_div_setup_fastlrm;
	radio_cmd_prop_tx       [i] = radio_cmd_prop_tx_fastlrm       ;
	radio_cmd_prop_tx_adv   [i] = radio_cmd_prop_tx_adv_fastlrm   ;
	radio_cmd_prop_rx       [i] = radio_cmd_prop_rx_fastlrm       ;
	radio_cmd_fs            [i] = radio_cmd_fs_fastlrm            ;
}

/***************************************************************/

uint8_t  radioSetupDataProtocol[ MAX_RADIO_SETUPS ];
uint8_t radioSetupsCount;
//void radioSetup_configureFromBuffer(const uint32_t* radioData, uint16_t radioDataLength) {
//	 uint8_t* p = (uint8_t*) radioData;
void radioSetup_configureFromBuffer(const uint8_t* radioData, uint16_t radioDataLength) {
	 const uint8_t* p = radioData;
/*
	 uint8_t dataProtocol = DATA_PROTOCOL_ATLAS; // 8 bits
	 uint8_t modulation   = MODULATION_TYPE_FSK; // 2 bits
	 uint8_t txPower      = 10;                  // 6 bits signed
	 uint8_t msbFirst     = 1;                   // 1 bit
	 uint8_t swBits       = 32;                  // 6 bits unsigned
	 uint8_t fecWhiten    = DATA_ENCODING_PLAIN;    // 8 bits
*/
	 //uint8_t i = 0;
	 radioSetupsCount = 0;

	 while ((p - (uint8_t*) radioData) < radioDataLength) {
		 uint8_t b;
		 uint8_t dataProtocol = *(p++); // 8 bits
		 b = *(p++);
		 uint8_t modulation   = (b >> 6) & 0x03; // 2 bits
		 uint8_t txPower      = (b & 0x3F) - 32; // 6 bits signed
		 b = *(p++);
		 uint8_t msbFirst     = (b >> 7);                   // 1 bit
		 uint8_t swBits       = (b & 0x3F);                 // 6 bits unsigned
		 uint8_t fecWhiten    = *(p++);    // 8 bits

		 uint32_t syncWord    = *( (uint32_t*) p ); p+=4;
		 uint32_t freq        = *( (uint32_t*) p ); p+=4;
		 uint32_t dev         = *( (uint32_t*) p ); p+=4;
		 uint32_t symbRate    = *( (uint32_t*) p ); p+=4;
		 uint32_t rxBw        = *( (uint32_t*) p ); p+=4;

		 System_printf("%d>> %08x %d %d %d %d -- %d %d %d %d %d %d\n", radioSetupsCount, syncWord, freq, dev, symbRate, rxBw, dataProtocol,modulation,txPower,msbFirst,swBits,fecWhiten);

		 radioSetup_modulation  (radioSetupsCount, modulation,symbRate,dev,rxBw);
		 radioSetup_txPower     (radioSetupsCount, txPower);
		 radioSetup_packetFormat(radioSetupsCount, fecWhiten);
		 radioSetup_frequency   (radioSetupsCount, freq);

		 radioSetupDataProtocol[ radioSetupsCount ] = dataProtocol;
		 // sync word missing still

		 radioSetupsCount++;
	 }
	 //return radioSetupsCount;
}

// was in tag.c

uint32_t ratDiffToUs(uint32_t now, uint32_t rat_time) {
  if (now > rat_time) {
  	return ((UINT_MAX - now) + rat_time) / 4; // microseconds to wrap around, because RAT runs at 4MHz
  } else {
  	return (rat_time - now) / 4;
  }
}

